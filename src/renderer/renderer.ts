import { TimestampFormatting } from "list-formatting";
import { BunchMeta, Order, Outline, Text } from "list-positions";
import {
  onFileChange,
  onSignalClose,
  setupReceiveIpc,
} from "./ipc/receive_ipc";
import { callMain } from "./ipc/send_ipc";
import { QuillWrapper, WrapperOp } from "./quill_wrapper";
import { Update, UpdatePre } from "./updates";

void (async function () {
  setupReceiveIpc();

  console.log("loadInitial...");
  const initialLines = await callMain("loadInitial");
  console.log("loaded");
  const quill = new QuillWrapper(onLocalOps, QuillWrapper.makeInitialState());
  const order = quill.richList.order;
  // TODO: unified replicaID, generated by us.
  const replicaID = quill.richList.formatting.replicaID;
  quill.applyOps(opsFromLines(initialLines, order));

  // --- Reloading ---
  onFileChange((allLines) => {
    console.log("Reloading...");
    // TODO: if it's a suffix of existing lines (fast-forward), just applyOps.
    const oldSel = quill.getSelection();
    quill.load(QuillWrapper.makeInitialState());
    quill.applyOps(opsFromLines(allLines, order));
    quill.setSelection(oldSel);
    console.log("reloaded");
  });

  // --- Saving ---

  window.onblur = () => {
    void save();
  };
  onSignalClose(save);

  // To avoid an excessive number of updates (hence JSON overhead),
  // we accumulate all of a save's changes into a single update of
  // each type (see update.ts).
  let pendingMetas: BunchMeta[] = [];
  const pendingSets = new Text(order);
  const pendingDeletes = new Outline(order);
  const pendingMarks = new TimestampFormatting(order);
  function onLocalOps(ops: WrapperOp[]): void {
    for (const op of ops) {
      switch (op.type) {
        case "metas":
          pendingMetas.push(...op.metas);
          break;
        case "set":
          pendingSets.set(op.startPos, op.chars);
          break;
        case "delete":
          for (const pos of Order.startPosToArray(op.startPos, op.count ?? 1)) {
            if (pendingSets.has(pos)) {
              // Don't record the set at all.
              pendingSets.delete(pos);
            } else pendingDeletes.add(pos);
          }
          break;
        case "marks":
          for (const mark of op.marks) {
            pendingMarks.addMark(mark);
          }
          break;
      }
    }
  }

  let idCounter = 0;
  function nextID(): string {
    return `${replicaID}_${idCounter++}`;
  }

  let inSave = false;
  async function save(): Promise<void> {
    if (inSave) return;

    console.log("saving...");

    const lines: string[] = [];
    /**
     * @param isMeta If true, the update is prefixed by "meta ".
     * Use this for updates that have no direct effect on the state but that may
     * be dependencies of later updates. The merge driver handles these specially
     * to avoid missing dependencies during cherry-picking.
     * (Otherwise, the merge driver treats all updates as opaque, to make it easy
     * to add new update types later.)
     */
    function addUpdate(updatePre: UpdatePre, isMeta = false): void {
      const update: Update = { id: nextID(), ...updatePre };
      lines.push((isMeta ? "meta " : "") + JSON.stringify(update));
    }

    if (pendingMetas.length !== 0) {
      addUpdate(
        {
          type: "metas",
          // TODO: compress (custom serializer)?
          metas: pendingMetas,
        },
        true
      );
      pendingMetas = [];
    }

    // TODO: activeMarks instead.
    const theMarks = [...pendingMarks.marks()];
    if (theMarks.length !== 0) {
      addUpdate({ type: "marks", marks: theMarks });
      pendingMarks.clear();
    }

    if (pendingSets.length !== 0) {
      addUpdate({ type: "sets", sets: pendingSets.save() });
      pendingSets.clear();
    }

    if (pendingDeletes.length !== 0) {
      addUpdate({
        type: "deletes",
        deletes: pendingDeletes.save(),
      });
      pendingDeletes.save();
    }

    inSave = true;
    try {
      await callMain("save", lines);
    } finally {
      inSave = false;
    }
    console.log("saved");
  }
})();

function opsFromLines(lines: string[], order: Order): WrapperOp[] {
  const ops: WrapperOp[] = [];
  for (let line of lines) {
    // Strip off the "meta " at the start of metadata lines.
    if (line.startsWith("meta ")) {
      line = line.slice(5);
    }
    const update = JSON.parse(line) as Update;
    switch (update.type) {
      case "metas": {
        ops.push({ type: "metas", metas: update.metas });
        break;
      }
      case "sets": {
        // TODO: optimize by skipping Text construction? Likewise for deletes.
        const text = new Text(order);
        text.load(update.sets);
        for (const [startPos, chars] of text.items()) {
          ops.push({ type: "set", startPos, chars });
        }
        break;
      }
      case "deletes": {
        const outline = new Outline(order);
        outline.load(update.deletes);
        for (const [startPos, count] of outline.items()) {
          ops.push({ type: "delete", startPos, count });
        }
        break;
      }
      case "marks": {
        ops.push({ type: "marks", marks: update.marks });
        break;
      }
      default:
        console.error(`Unknown update type, skipping: "${line}"`);
    }
  }
  return ops;
}
